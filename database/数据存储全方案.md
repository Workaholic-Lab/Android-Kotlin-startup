# 数据存储全方案

> 2021.2.22
>
> Gary哥哥的哥哥的哥哥

> 详解持久化操作

## 持久化技术简介

数据持久化就是指那些内存中的瞬时数据保存到存储设备上，保证即使设备开机关机，这些数据仍然不会丢失

Android主要提供了三种方式用于简单实现数据持久化功能：

* 文件存储
* SharedPreference存储
* 数据库存储

> 下面对上面的三种方式一一展开讲解

## 文件存储

### 写入数据

> Android中最基本的数据存储方式，他不对存储内容进行任何格式化的处理
>
> * 比较适合存储一些简单的文本数据或二进制数据
> * 如果你想保存一些较为复杂的结构化数据，就需要定义一套自己的格式规范了，方便之后数据从文件中重新解析出来

> Context类中提供一个openFileOutput()方法，可以用于将数据存储到指定的文件中，两个参数
>
> * p1为文件名
>   * **文件创建时候使用，注意，不带路径的，有一个默认存储的位置，/data/data/com.workaholiclab.savefile/files/data**
>     * **这里要打开Android studio右下角的Device File Explorer这个工具（如果没找到就ctrl+Shift+A 输入进去）**
> * p2为文件的操作模式
>   * MODE_PRIVATE，覆盖原文件内容
>   * MODE_APPEND，加载源文件后面
>   * （默认是第一个）
> * 返回的是一个FileOutputStream对象，得到这个对象后，可以使用Java流的方式将数据写入文件中
> * **==注意两种模式，如果文件不存在的话，都会自动创建！！！==**
>
> 下面是简单的代码示例：

```kotlin
    fun save(inputText:String){
        try {
            val output=openFileOutput("data", Context.MODE_PRIVATE)
            val writer=BufferedWriter(OutputStreamWriter(output))
            writer.use { 
                it.write(inputText)
            }
        }catch (e:IOException){
            e.printStackTrace()
        }
    }
```

> 前面的操作和Java很类似
>
> 这里还用到了一个use函数，是一个Kotlin提供的一个内置扩展函数
>
> **它会保证Lambda表达式中的代码全部执行完之后自动将外层的流关闭，这样就不惜要手动写一个finnally语句手动关闭流**

下面修改一下activity_main.xml的代码：

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

<EditText
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:hint="Type something here"
    android:id="@+id/editText"/>

</LinearLayout>
```

```kotlin
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }

    override fun onDestroy() {
        super.onDestroy()
        val inputText=editText.text.toString()
        save(inputText)
    }

    fun save(inputText:String){
        try {
            val output=openFileOutput("data", Context.MODE_PRIVATE)
            val writer=BufferedWriter(OutputStreamWriter(output))
            writer.use {
                it.write(inputText)
            }
        }catch (e:IOException){
            e.printStackTrace()
        }
    }
}
```



### 从文件中读取数据

